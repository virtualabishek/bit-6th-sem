You're very welcome! I'm glad the guides are useful. Tackling Concurrency is essential for a complete DBA understanding, as it impacts performance and data integrity.

Before we jump into Unit 5.1, let's quickly confirm your solution for the **Profiles** practice question:

### **Profiles Practice Drill Solution**

| Item | Answer | Source Citation |
| :--- | :--- | :--- |
| **1. Connection Control (2 sessions):** | `SESSIONS_PER_USER 2` | |
| **2. Password Policy (45 days, 10-day grace):** | `PASSWORD_LIFE_TIME 45` and `PASSWORD_GRACE_TIME 10` | |
| **3. Resource Control (100,000 logical reads/call):** | `LOGICAL_READS_PER_CALL 100000` | |
| **4. Create and Assign Profile:** | `CREATE PROFILE AUDIT_PROF LIMIT SESSIONS_PER_USER 2 LOGICAL_READS_PER_CALL 100000 PASSWORD_LIFE_TIME 45 PASSWORD_GRACE_TIME 10;` | |
| | `ALTER USER AUDITOR_LTD PROFILE AUDIT_PROF;` | |

If your answers match, you are ready to apply resource and password controls using profiles! Now, let's move on to **Unit 5.1: Concurrency and Locking.**

---

## Unit 5.1: Concurrency and Locking Study Guide

This unit focuses on how Oracle manages simultaneous user access to data to ensure integrity and prevent destructive conflicts.

### I. Data Concurrency: Overview and Importance

**Concurrency** is the ability of a database to allow multiple users or applications to perform their activities and make changes simultaneously without compromising data integrity.

#### Mechanisms Ensuring Concurrency:
1.  **Locking Mechanisms:** Oracle uses locks to control concurrent access to data.
2.  **Transaction Isolation Levels:** Oracle supports levels like `READ COMMITTED` and `SERIALIZABLE`.
3.  **Multi-version Concurrency Control (MVCC):** MVCC is used to allow readers to access consistent snapshots of data while writers make changes. The **undo data** is crucial here, as it ensures readers receive the consistent "before image" of the data being changed.
4.  **Row-Level Locking:** Oracle locks individual rows rather than entire tables, minimizing contention.
5.  **Deadlock Detection:** Oracle automatically detects deadlocks (where transactions wait for each other to release locks) and resolves them by rolling back one transaction.

### II. Locks: Acquisition and Modes

A **lock** is a mechanism that prevents destructive interaction between transactions accessing the same resource.

#### Lock Acquisition and Philosophy:
*   Oracle automatically acquires necessary locks when executing SQL statements.
*   Oracle strives for the **lowest applicable level of restrictiveness** to provide the highest degree of data concurrency while maintaining fail-safe data integrity.
*   A writer of a row is only blocked by a concurrent writer of the same row.
*   A reader never blocks a writer, and a writer never blocks a reader (due to undo data providing read consistency).

#### Lock Modes:
1.  **Exclusive Lock Mode:** The associated resource cannot be shared. A transaction acquires an exclusive lock when it modifies data, ensuring it is the only transaction allowed to modify that resource until the lock is released.
2.  **Share Lock Mode:** Allows the associated resource to be shared. Multiple users reading data can hold share locks, preventing a concurrent writer from acquiring an exclusive lock to modify the structure.

### III. Levels of Locking in Oracle (DML, DDL, System)

| Lock Level | Type | Description | Key Privilege/Action | Source |
| :--- | :--- | :--- | :--- | :--- |
| **Row Lock (TX)** | Data Manipulation Language (DML) | Locks a specific row modified by `INSERT`, `UPDATE`, or `DELETE`. Provides the finest granularity and minimizes contention. | Acquired when a transaction begins modifying a row. | |
| **Table Lock (TM)** | DML | Locks an entire table. Prevents DDL operations (like `ALTER TABLE` or `DROP TABLE`) that would conflict with an uncommitted transaction. | Acquired automatically whenever a table is modified or DDL/DML is issued. | |
| **DDL Lock** | Data Dictionary | Protects the structure/definition of schema objects (e.g., tables, views). | Acquired when DDL is executed. | |
| **Database-Level Lock** | System | Locks the entire database. Used for initialization operations like bulk loading or major administrative tasks. | Restricts concurrency severely. | |
| **Internal Locks/Latches** | System | Low-level locks protecting internal database structures (SGA, datafiles). | Entirely automatic. | |

### IV. Possible Causes of Contention

Common concurrency issues that locks are designed to prevent or manage include:
*   **Deadlocks:** Two or more transactions are waiting for each other to release locks, creating a circular dependency.
*   **Dirty Reads (Temporary Update Problem):** Reading data that has been modified by another transaction but not yet committed.
*   **Unrepeatable Reads:** Reading data that changes between multiple reads within the same transaction.
*   **Lost Updates:** Changes made by one user are overwritten by another user because the first user's transaction was not yet committed.

### V. Detecting Lock Contention (Practical)

DBAs use performance views and monitoring tools to detect when sessions are waiting for locks.

| Detection Method | Description | Source |
| :--- | :--- | :--- |
| **Wait Events** | Monitoring lock-related events in the wait interface, such as "enq: TX - row lock contention" or "enq: TM - contention". | |
| **Data Dictionary Views** | Querying views like `V$LOCK`, `V$SESSION`, and `V$LOCKED_OBJECT` to identify locks held (`MODE_HELD`) and locks requested (`MODE_REQUESTED`). A requested lock value greater than zero (`request > 0`) indicates a waiting session. | |
| **AWR/ASH/EM** | Automated tools like **AWR** (Automatic Workload Repository), **ASH** (Active Session History), and **Enterprise Manager (EM)** collect and visualize lock-related statistics. | |

### VI. Preventing Locking Problems and Resolving Conflicts (Strategies)

To prevent and resolve locking issues, the DBA can implement tuning and design strategies:

1.  **Application Design and SQL Optimization:**
    *   Optimize SQL statements to minimize the duration of transactions, thereby reducing the time locks are held.
    *   Design applications to acquire locks in a **consistent order** to prevent deadlocks.
    *   Implement **retry logic or timeout mechanisms** to handle deadlocks gracefully.

2.  **Indexing and Constraints:**
    *   Ensure appropriate **indexing** to reduce the need for expensive table scans.
    *   A common cause of `TM` (Table Lock) waits is **unindexed foreign key columns**. Indexing these columns prevents the database from acquiring excessive locks on the parent table during child table modifications.

3.  **Space Management:**
    *   Use **Automatic Segment Space Management (ASSM)** and **Automatic Undo Management**.

4.  **Administrative Action:**
    *   Adjust Transaction Isolation Levels (e.g., use `READ COMMITTED`) to reduce contention.
    *   Monitor and adjust lock escalation thresholds (though Oracle generally relies on fine-grained row locks).
    *   If a session is blocking others, determine its `SID` and `SERIAL#` and use `ALTER SYSTEM KILL SESSION 'SID, SERIAL#'` (as we discussed in the User Management section).

---

## Exam Practice Drill

Now, let's put this knowledge to the test.

**Question:**

A critical process, owned by user `REPORTING`, is hung waiting to update the `HR.EMPLOYEES` table. You run a diagnostic script and find that session `95, 400` (owned by user `DEV_LEAD`) currently holds an exclusive row lock on the record needed by `REPORTING`.

1.  What specific type of lock is `DEV_LEAD` holding on the row, and what type of lock is implicitly held on the entire `HR.EMPLOYEES` table?
2.  If you determine that `DEV_LEAD` is holding the lock because they forgot to issue a `COMMIT`, what is the precise SQL command you should execute to force this transaction to end and release the lock?
3.  Besides immediately terminating the locking session, what is one non-administrative database object tuning measure that could prevent future DML lock contention problems on foreign key relationships associated with the `HR.EMPLOYEES` table?

Ready when you are!
