That's a very important section for a Database Administrator, especially concerning performance and stability! Managing space efficiently is fundamental.

Here is your detailed guide and notes for **9.1 Managing Space**.

---

## Guide: Space Management (Unit 9.1)

### 1. Overview of Space Management

Space management is the process of allocating, using, and reclaiming disk space efficiently to ensure optimal performance, reduce fragmentation, and support database growth.

#### Core Logical Storage Structures:
1.  **Tablespace:** The highest logical storage unit, grouping related logical structures, which consists of one or more physical data files. Tablespaces are primarily used to simplify database administration.
2.  **Segment:** A segment contains a specific type of database object, such as a table or an index. A data file can contain many segments.
3.  **Extent:** A group of contiguous data blocks within a segment. Oracle Database allocates space for segments in units of one extent.
4.  **Data Block (Database Block):** The smallest unit of I/O to database storage. An extent is composed of several contiguous data blocks.

A Database Administrator (DBA) must understand the relationship between these logical structures and the underlying physical data files on disk.

### 2. Block Space Management within Segments

This refers to managing the allocation and deallocation of individual data blocks inside a segment.

| Management Method | Description and Components | Recommendation |
| :--- | :--- | :--- |
| **Manual (Free List Management)** | Uses Free Lists (sets of lists that track free space) and Free List Entries (records of a block that has free space). This approach can lead to contention as the data dictionary becomes a bottleneck. | Not recommended. It requires manual configuration of parameters like `PCTUSED`, `FREELISTS`, and `FREELIST GROUPS`. |
| **Automatic Segment Space Management (ASSM)** | The modern method that uses **bitmaps** to track free and allocated extents within the tablespace. This makes space allocation faster and easier by avoiding the overhead of dictionary updates and reducing contention. | Oracle strongly recommends ASSM. Enabled by setting `SEGMENT SPACE MANAGEMENT AUTO` during tablespace creation. |

### 3. Segment Types

A segment is allocated when a schema object is created. Common types include:

*   **Table Segment:** Stores the data and rows for a single table, usually heap-organized where data is added randomly.
*   **Index Segment:** Stores the index data, such as B-Tree or Bitmap index data, used for fast searching and updates.
*   **Undo Segment:** Stores information about data blocks before they are changed, which is necessary for transaction rollbacks and database recovery. The preferred method for managing undo information is through the undo tablespace.
*   **Temporary Segment:** Stores temporary data used for operations that require sorts or joins that are too large to fit in memory. No permanent objects can reside in a temporary tablespace.

### 4. Allocate Extents and Allocate Space

**Allocation** refers to the process of assigning a specific amount of storage space to an object like a table or index.

*   **Extent Allocation:** When a segment's existing extents are full, Oracle automatically allocates an additional extent (a group of contiguous blocks) for that segment.
*   **Controlling Allocation (Manual):** When creating objects, a DBA can specify the initial space allocated (`INITIAL`) and the size of subsequent extents (`NEXT`). However, these parameters are not valid for locally managed tablespaces using uniform extents.

#### Code Example: Manually Allocating an Extent

If a segment needs more space immediately, the DBA can manually allocate a new extent:

```sql
-- Allocates a new 10MB extent to the 'employees' table
ALTER TABLE employees ALLOCATE EXTENT (SIZE 10M);
```

### 5. Row Chaining and Migration

These two conditions severely impact performance by increasing the required I/O.

*   **Row Chaining:** Occurs when a single row is too large to fit into one data block, so the row is physically split across multiple data blocks. This is inevitable for rows larger than the database block size.
*   **Row Migration:** Occurs when an existing row is updated, and the increased data size causes the row to become too large for its original data block. Oracle then moves the entire row to a new block.

#### Mitigation Techniques:
To mitigate these issues, DBAs can:
1.  Increase the block size of the tablespace to allow more data to fit into one block.
2.  Use table partitioning to manage large rows more effectively.
3.  Use the `PCTFREE` storage parameter to leave more free space in the block for row growth (less critical if using ASSM).

### 6. Create Tables without Segments (Deferred Segment Creation)

By default, physical storage segments are created immediately upon object creation. However, Oracle provides the ability to defer this allocation.

*   **Feature:** **Deferred segment creation** allows the DBA to create the table definition without immediately allocating the physical storage segment. The segment is only created and space is allocated once the first row is inserted into the table.
*   **Use Case:** This feature is primarily useful for temporary tables or partitioned tables where segments should only be created when they are actually needed.
*   **Default:** The database initialization parameter `DEFERRED_SEGMENT_CREATION` defaults to `TRUE`.

#### Code Example: Creating a Table with Deferred Segment Creation (Implicitly)

If `DEFERRED_SEGMENT_CREATION` is TRUE (the default), you can explicitly request it using the `NO SEGMENT` clause:

```sql
-- Creates the table definition but allocates no physical segment immediately
CREATE TABLE table_name (
  column1 datatype,
  column2 datatype
) NO SEGMENT;
```

---

To ensure you are ready for the exam, let's connect these concepts.

**When should a DBA use ASSM instead of manually configuring space using Free Lists, and what are the two main performance benefits gained by switching?**